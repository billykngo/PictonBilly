This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2025-03-05T02:09:37.697Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
api/
  core/
    __init__.py
    exceptions.py
    permissions.py
  migrations/
    __init__.py
    0001_initial.py
    0002_user_first_name_user_last_name.py
    0003_user_role.py
    0004_formtemplate_user_signature_alter_user_role_and_more.py
    0005_remove_formsubmission_updated_at_and_more.py
  serializers/
    __init__.py
    adminSerializer.py
    authSerializer.py
    formSerializer.py
    userSerializer.py
  views/
    forms/
      __init__.py
      form_approval.py
      form_submission.py
      form_template.py
    __init__.py
    admin_dashboard.py
    authentication.py
    common.py
    user_management.py
  __init__.py
  admin.py
  apps.py
  models.py
  urls.py
config/
  asgi.py
  settings.py
  urls.py
  wsgi.py
templates/
  forms/
    term_withdrawal.tex
utils/
  __init__.py
  formgenerator.py
  MethodNameMixin.py
  prettyPrint.py
Dockerfile
environment.yml
manage.py
requirements.txt
startup.sh
startupLinux.sh

================================================================
Repository Files
================================================================

================
File: api/core/__init__.py
================
from .exceptions import InvalidCredentialsError, AccountInactiveError, UserExistsError
from .permissions import IsAdminOrSelf, IsActiveUser

__all__ = [
    "InvalidCredentialsError",
    "AccountInactiveError",
    "IsAdminOrSelf",
    "IsActiveUser",
]

================
File: api/core/exceptions.py
================
from rest_framework.exceptions import APIException
from rest_framework import status


class AccountInactiveError(APIException):
    status_code = status.HTTP_403_FORBIDDEN
    default_detail = "Your Account is Inactive"


class InvalidCredentialsError(APIException):
    status_code = status.HTTP_401_UNAUTHORIZED
    default_detail = "Invalid Credentials Provided"


class UserExistsError(APIException):
    status_code = status.HTTP_409_CONFLICT
    default_detail = "User Already Exists"

================
File: api/core/permissions.py
================
from rest_framework import permissions


class IsAdminOrSelf(permissions.BasePermission):
    """Allow users to edit their own profiles"""

    def has_object_permission(self, request, view, obj):
        # allow admin full access
        if request.user.is_superuser:
            return True
        # only allow for other users to edit their own profile
        return obj.id == request.user.id


class IsActiveUser(permissions.BasePermission):
    """Only allolw active users to access the API"""

    def has_permission(self, request, view):
        return request.user and request.user.is_active

================
File: api/migrations/__init__.py
================


================
File: api/migrations/0001_initial.py
================
# Generated by Django 5.1.6 on 2025-02-17 08:26

from django.db import migrations, models


class Migration(migrations.Migration):
    initial = True

    dependencies = [
        ("auth", "0012_alter_user_first_name_max_length"),
    ]

    operations = [
        migrations.CreateModel(
            name="User",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                (
                    "last_login",
                    models.DateTimeField(
                        blank=True, null=True, verbose_name="last login"
                    ),
                ),
                ("username", models.CharField(max_length=40, unique=True)),
                ("email", models.EmailField(max_length=254, unique=True)),
                ("password", models.CharField(max_length=128)),
                ("phone_number", models.CharField(blank=True, max_length=15)),
                ("date_of_birth", models.DateField(blank=True, null=True)),
                ("created_at", models.DateTimeField(auto_now_add=True)),
                ("updated_at", models.DateTimeField(auto_now=True)),
                ("is_active", models.BooleanField(default=True)),
                ("is_superuser", models.BooleanField(default=False)),
                ("is_staff", models.BooleanField(default=False)),
                (
                    "groups",
                    models.ManyToManyField(
                        blank=True,
                        help_text="The groups this user belongs to. A user will get all permissions granted to each of their groups.",
                        related_name="user_set",
                        related_query_name="user",
                        to="auth.group",
                        verbose_name="groups",
                    ),
                ),
                (
                    "user_permissions",
                    models.ManyToManyField(
                        blank=True,
                        help_text="Specific permissions for this user.",
                        related_name="user_set",
                        related_query_name="user",
                        to="auth.permission",
                        verbose_name="user permissions",
                    ),
                ),
            ],
            options={
                "abstract": False,
            },
        ),
    ]

================
File: api/migrations/0002_user_first_name_user_last_name.py
================
# Generated by Django 5.1.6 on 2025-02-18 05:01

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('api', '0001_initial'),
    ]

    operations = [
        migrations.AddField(
            model_name='user',
            name='first_name',
            field=models.CharField(default='', max_length=128),
        ),
        migrations.AddField(
            model_name='user',
            name='last_name',
            field=models.CharField(default='', max_length=128),
        ),
    ]

================
File: api/migrations/0003_user_role.py
================
# Generated by Django 5.0.1 on 2025-02-21 02:05

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('api', '0002_user_first_name_user_last_name'),
    ]

    operations = [
        migrations.AddField(
            model_name='user',
            name='role',
            field=models.CharField(choices=[('basicuser', 'Basic User'), ('admin', 'Admin')], default='basicuser', max_length=30),
        ),
    ]

================
File: api/migrations/0004_formtemplate_user_signature_alter_user_role_and_more.py
================
# Generated by Django 5.1.6 on 2025-02-27 17:58

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('api', '0003_user_role'),
    ]

    operations = [
        migrations.CreateModel(
            name='FormTemplate',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
                ('description', models.TextField(blank=True)),
                ('latex_template', models.TextField()),
                ('field_schema', models.JSONField(help_text='JSON schema defining form fields')),
                ('required_approvals', models.PositiveIntegerField(default=1)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
            ],
        ),
        migrations.AddField(
            model_name='user',
            name='signature',
            field=models.ImageField(blank=True, null=True, upload_to='signatures/'),
        ),
        migrations.AlterField(
            model_name='user',
            name='role',
            field=models.CharField(choices=[('basicuser', 'Basic User'), ('admin', 'Admin')], default='student', max_length=30),
        ),
        migrations.CreateModel(
            name='FormSubmission',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('form_data', models.JSONField(help_text='JSON data containing form field values')),
                ('current_pdf', models.FileField(blank=True, null=True, upload_to='form_pdfs/')),
                ('status', models.CharField(choices=[('draft', 'Draft'), ('pending', 'Pending Approval'), ('returned', 'Returned for Changes'), ('approved', 'Approved'), ('rejected', 'Rejected')], default='draft', max_length=20)),
                ('current_step', models.PositiveIntegerField(default=0)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('submitter', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='form_submissions', to=settings.AUTH_USER_MODEL)),
                ('form_template', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='submissions', to='api.formtemplate')),
            ],
        ),
        migrations.CreateModel(
            name='FormApproval',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('step_number', models.PositiveIntegerField()),
                ('decision', models.CharField(choices=[('approved', 'Approved'), ('returned', 'Returned for Changes'), ('rejected', 'Rejected')], max_length=20)),
                ('comments', models.TextField(blank=True)),
                ('signed_pdf', models.FileField(blank=True, null=True, upload_to='signed_pdfs/')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('approver', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='form_approvals', to=settings.AUTH_USER_MODEL)),
                ('form_submission', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='approvals', to='api.formsubmission')),
            ],
            options={
                'unique_together': {('form_submission', 'approver', 'step_number')},
            },
        ),
        migrations.CreateModel(
            name='FormApprovalWorkflow',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('approver_role', models.CharField(choices=[('basicuser', 'Basic User'), ('admin', 'Admin')], max_length=30)),
                ('order', models.PositiveIntegerField(help_text='Order in the approval sequence')),
                ('form_template', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='approvals_workflows', to='api.formtemplate')),
            ],
            options={
                'ordering': ['order'],
                'unique_together': {('form_template', 'order')},
            },
        ),
    ]

================
File: api/migrations/0005_remove_formsubmission_updated_at_and_more.py
================
# Generated by Django 5.1.6 on 2025-03-05 01:49

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('api', '0004_formtemplate_user_signature_alter_user_role_and_more'),
    ]

    operations = [
        migrations.RemoveField(
            model_name='formsubmission',
            name='updated_at',
        ),
        migrations.RemoveField(
            model_name='formtemplate',
            name='latex_template',
        ),
        migrations.AddField(
            model_name='formapproval',
            name='signed_pdf_url',
            field=models.TextField(null=True),
        ),
        migrations.AddField(
            model_name='formsubmission',
            name='pdf_url',
            field=models.TextField(null=True),
        ),
        migrations.AlterField(
            model_name='formapproval',
            name='signed_pdf',
            field=models.FileField(blank=True, null=True, upload_to='forms/signed_pdfs/'),
        ),
        migrations.AlterField(
            model_name='formapprovalworkflow',
            name='approver_role',
            field=models.CharField(choices=[('student', 'Student'), ('admin', 'Admin'), ('staff', 'Staff')], max_length=30),
        ),
        migrations.AlterField(
            model_name='formsubmission',
            name='current_pdf',
            field=models.FileField(blank=True, null=True, upload_to='forms/form_pdfs/'),
        ),
        migrations.AlterField(
            model_name='user',
            name='role',
            field=models.CharField(choices=[('student', 'Student'), ('admin', 'Admin'), ('staff', 'Staff')], default='student', max_length=30),
        ),
    ]

================
File: api/serializers/__init__.py
================
from .authSerializer import LoginSerializer, RegisterSerializer
from .userSerializer import UserSerializer, UserDetailSerializer
from .adminSerializer import AdminUserSerializer
from .formSerializer import (
    FormTemplateSerializer,
    FormSubmissionSerializer,
    FormApprovalSerializer,
)


__all__ = [
    "LoginSerializer",
    "RegisterSerializer",
    "UserSerializer",
    "UserDetailSerializer",
    "AdminUserSerializer",
    "FormTemplateSerializer",
    "FormSubmissionSerializer",
    "FormApprovalSerializer",
]

================
File: api/serializers/adminSerializer.py
================
from rest_framework import serializers
from ..models import User


class AdminUserSerializer(serializers.ModelSerializer):
    """Serializer for admin dashboard with additional fields"""

    class Meta:
        model = User
        fields = [
            "id",
            "username",
            "email",
            "first_name",
            "last_name",
            "phone_number",
            "role",
            "is_active",
            "is_staff",
            "is_superuser",
            "date_of_birth",
            "created_at",
            "updated_at",
        ]
        read_only_fields = ["id", "created_at", "updated_at"]

================
File: api/serializers/authSerializer.py
================
from rest_framework import serializers


class LoginSerializer(serializers.Serializer):
    """Serializer for login endpoint validation"""

    username = serializers.CharField(required=True)
    password = serializers.CharField(required=True)


class RegisterSerializer(serializers.Serializer):
    """Serializer for registration endpoint validation"""

    email = serializers.EmailField(required=True)
    username = serializers.CharField(required=True)
    password = serializers.CharField(required=True, write_only=True)
    firstName = serializers.CharField(required=True)
    lastName = serializers.CharField(required=True)
    phone = serializers.CharField(required=True)

================
File: api/serializers/formSerializer.py
================
from rest_framework import serializers
from ..models import FormTemplate, FormSubmission, FormApproval, FormApprovalWorkflow


class FormApprovalWorkflowSerializer(serializers.ModelSerializer):
    class Meta:
        model = FormApprovalWorkflow
        fields = ["id", "approver_role", "order"]


class FormTemplateSerializer(serializers.ModelSerializer):
    approval_workflows = FormApprovalWorkflowSerializer(many=True, read_only=True)

    class Meta:
        model = FormTemplate
        fields = [
            "id",
            "name",
            "description",
            "field_schema",
            "required_approvals",
            "approval_workflows",
            "created_at",
            "updated_at",
        ]


class FormSubmissionSerializer(serializers.ModelSerializer):
    submitter_name = serializers.SerializerMethodField()
    template_name = serializers.SerializerMethodField()

    class Meta:
        model = FormSubmission
        fields = [
            "id",
            "form_template",
            "template_name",
            "submitter",
            "submitter_name",
            "form_data",
            "current_pdf",
            "status",
            "current_step",
            "created_at",
            "updated_at",
        ]
        read_only_fields = [
            "id",
            "created_at",
            "updated_at",
            "submitter_name",
            "template_name",
        ]

    def get_submitter_name(self, obj):
        return f"{obj.submitter.first_name} {obj.submitter.last_name}"

    def get_template_name(self, obj):
        return obj.form_template.name


class FormApprovalSerializer(serializers.ModelSerializer):
    approver_name = serializers.SerializerMethodField()

    class Meta:
        model = FormApproval
        fields = [
            "id",
            "form_submission",
            "approver",
            "approver_name",
            "step_number",
            "decision",
            "comments",
            "signed_pdf",
            "created_at",
        ]
        read_only_fields = ["id", "created_at", "approver_name"]

    def get_approver_name(self, obj):
        return f"{obj.approver.first_name} {obj.approver.last_name}"

================
File: api/serializers/userSerializer.py
================
from rest_framework import serializers
from ..models import User


class UserSerializer(serializers.ModelSerializer):
    """Basic User Serializer with limited fields"""

    class Meta:
        model = User
        fields = [
            "id",
            "username",
            "email",
            "first_name",
            "last_name",
            "is_active",
            "signature",
            "role",
        ]
        read_only_fields = ["id"]


class UserDetailSerializer(serializers.ModelSerializer):
    """Detailed user serializer with all fields"""

    class Meta:
        model = User
        fields = [
            "id",
            "username",
            "email",
            "first_name",
            "last_name",
            "phone_number",
            "role",
            "is_active",
            "is_staff",
            "created_at",
            "updated_at",
            "is_superuser",
            "signature",
        ]
        read_only_fields = ["id", "created_at", "updated_at"]

================
File: api/views/forms/__init__.py
================
from .form_approval import FormApprovalViewSet
from .form_submission import FormSubmissionViewSet
from .form_template import FormTemplateViewSet

__all__ = ["FormApprovalViewSet", "FormSubmissionViewSet", "FormTemplateViewSet"]

================
File: api/views/forms/form_approval.py
================
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated

from ...models import FormApproval
from ...serializers import (
    FormApprovalSerializer,
)
from ...core import IsActiveUser

from utils import MethodNameMixin, pretty_print
from django.conf import settings
from django.db.models import Q

DEBUG = settings.DEBUG


class FormApprovalViewSet(viewsets.ReadOnlyModelViewSet, MethodNameMixin):
    """ViewSet for viewing form approvals"""

    serializer_class = FormApprovalSerializer
    queryset = FormApproval.objects.all()
    permission_classes = [IsAuthenticated, IsActiveUser]

    def get_queryset(self):
        """Filter approvals based on user role"""
        user = self.request.user
        queryset = super().get_queryset()

        # Admins see all approvals
        if user.is_superuser:
            return queryset

        # Users see approvals for their own submissions and approvals they made
        return queryset.filter(Q(form_submission__submitter=user) | Q(approver=user))

================
File: api/views/forms/form_submission.py
================
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

from ...models import FormSubmission, FormTemplate, FormApproval, FormApprovalWorkflow
from ...serializers import FormSubmissionSerializer
from ...core import IsActiveUser

from utils import MethodNameMixin, pretty_print, FormPDFGenerator
from django.conf import settings
from django.db.models import OuterRef

DEBUG = settings.DEBUG


class FormSubmissionViewSet(viewsets.ModelViewSet, MethodNameMixin):
    """ViewSet for form submissions"""

    serializer_class = FormSubmissionSerializer
    queryset = FormSubmission.objects.all()
    permission_classes = [IsAuthenticated, IsActiveUser]

    def perform_create(self, serializer):
        # Set the submitter as the current user
        serializer.save(submitter=self.request.user)

    @action(detail=False, methods=["POST"])
    def preview(self, request):
        """
        Generate a preview PDF from form data without storing it to the database
        So user can preview pdf inside their dashboard
        """
        if DEBUG:
            pretty_print(
                f"Generating form preview from {self._get_method_name()}", "INFO"
            )

        # NOTE: The Form Type (Graduate Petition | Term Withdrawal)
        # More should be added in the future
        # Graduate Petition should have Form ID 1
        # Term Withdrawal should have Form ID 2
        form_template_id = request.data.get("form_template")

        # NOTE: this form_data is what were going to use to generate our pdf from the template
        # we should add error handling for this in its own class
        # different forms require different optional and required fields
        form_data = request.data.get("form_data")

        # Validate required fields
        if not form_template_id or not form_data:
            return Response(
                {"error": "Missing form_template or form_data"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        try:
            # Get the form template
            form_template = FormTemplate.objects.get(id=form_template_id)

            # Generate the PDF using util class without saving it to DB
            pdf_generator = FormPDFGenerator()

            # pass the template name so that we know which one to generate
            pdf_file = pdf_generator.generate_template_form(
                form_template.name, request.user, form_data
            )

            # Read PDF Content and encode as base64
            import base64

            pdf_content = pdf_file.read()
            pdf_base_64 = base64.b64encode(pdf_content).decode("utf-8")

            # Return PDF as base64 in the response
            return Response(
                {
                    "pdf_content": pdf_base_64,
                    "filename": f"{form_template.name}_preview.pdf",
                }
            )

        except FormTemplate.DoesNotExist:
            return Response(
                {"error": "Form template not found"}, status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            if DEBUG:
                pretty_print(f"Error generating preview: {str(e)}", "ERROR")
            return Response(
                {"error": f"Error generating preview: {str(e)}"},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR,
            )

    @action(detail=True, methods=["POST"])
    def submit(self, request, pk=None):
        """Submit a draft form for approval"""
        form_submission = self.get_object()

        # Ensure the form is in draft status
        if form_submission.status != "draft":
            return Response(
                {"error": "Only draft forms can be submitted for approval"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # Get the form template's approval workflow
        approval_workflows = (
            form_submission.form_template.approvals_workflows.all().order_by("order")
        )

        if not approval_workflows.exists():
            # If no approval workflow, mark as approved immediately
            form_submission.status = "approved"
            form_submission.save()
            return Response(
                {"status": "approved", "message": "Form approved automatically"}
            )

        # Set form to pending approval and set current step to first approval step
        form_submission.status = "pending"
        form_submission.current_step = approval_workflows.first().order
        form_submission.save()

        if DEBUG:
            pretty_print(
                f"Form {form_submission.id} submitted for approval, current step: {form_submission.current_step}",
                "INFO",
            )

        # Generate final PDF with official timestamp
        self._generate_pdf(form_submission.form_template.name, form_submission)

        return Response(
            {
                "status": "pending",
                "current_step": form_submission.current_step,
                "approver_role": approval_workflows.first().approver_role,
            }
        )

    @action(detail=True, methods=["POST"])
    def approve(self, request, pk=None):
        """Approve a form at the current step"""
        form_submission = self.get_object()

        # Ensure the form is in pending status
        if form_submission.status != "pending":
            return Response(
                {"error": "Only pending forms can be approved"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # Check if the current user has the right role to approve at this step
        user_role = request.user.role
        current_workflow = form_submission.form_template.approvals_workflows.filter(
            order=form_submission.current_step
        ).first()

        if not current_workflow or current_workflow.approver_role != user_role:
            return Response(
                {
                    "error": "You don't have permission to approve this form at this step"
                },
                status=status.HTTP_403_FORBIDDEN,
            )

        # Create approval record
        approval = FormApproval.objects.create(
            form_submission=form_submission,
            approver=request.user,
            step_number=form_submission.current_step,
            decision="approved",
            comments=request.data.get("comments", ""),
        )

        # Generate signed PDF for this approval
        signed_pdf = self._generate_signed_pdf(form_submission, approval)
        approval.signed_pdf = signed_pdf
        approval.save()

        # Check if there are more steps in the workflow
        next_workflow = (
            form_submission.form_template.approvals_workflows.filter(
                order__gt=form_submission.current_step
            )
            .order_by("order")
            .first()
        )

        if next_workflow:
            # Move to next step
            form_submission.current_step = next_workflow.order
            form_submission.save()
            return Response(
                {
                    "status": "pending",
                    "current_step": form_submission.current_step,
                    "approver_role": next_workflow.approver_role,
                }
            )
        else:
            # Final approval
            form_submission.status = "approved"
            form_submission.save()
            return Response({"status": "approved", "message": "Form fully approved"})

    @action(detail=True, methods=["POST"])
    def return_for_changes(self, request, pk=None):
        """Return a form for changes"""
        form_submission = self.get_object()

        # Similar logic to approve but mark as returned
        if form_submission.status != "pending":
            return Response(
                {"error": "Only pending forms can be returned for changes"},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # Check permissions similar to approve method
        user_role = request.user.role
        current_workflow = form_submission.form_template.approvals_workflows.filter(
            order=form_submission.current_step
        ).first()

        if not current_workflow or current_workflow.approver_role != user_role:
            return Response(
                {"error": "You don't have permission to return this form at this step"},
                status=status.HTTP_403_FORBIDDEN,
            )

        # Record return decision
        FormApproval.objects.create(
            form_submission=form_submission,
            approver=request.user,
            step_number=form_submission.current_step,
            decision="returned",
            comments=request.data.get("comments", ""),
        )

        # Update form status
        form_submission.status = "returned"
        form_submission.save()

        return Response({"status": "returned", "message": "Form returned for changes"})

    def _generate_pdf(self, template_name, form_submission):
        """Generate PDF for the form submission"""
        pretty_print(
            f"RECEIVED INSIDE _generate_pdf: {template_name} {form_submission}", "DEBUG"
        )
        try:
            pdf_generator = FormPDFGenerator()
            pdf_file = pdf_generator.generate_template_form(
                template_name,
                form_submission.submitter,
                form_submission.form_data,
            )

            # Update the form submission with the generated PDF
            form_submission.current_pdf = pdf_file
            form_submission.save()

            return pdf_file
        except Exception as e:
            if DEBUG:
                pretty_print(f"Error generating PDF: {str(e)}", "ERROR")
            return None

    def _generate_signed_pdf(self, form_submission, approval):
        """Generate signed PDF for the approval"""
        # TODO: need to do this complete need to make it required for user to
        # submit their signature into their account before being able to access
        # forms sidepanel
        try:
            # WARNING: for right now just send back current pdf
            return form_submission.current_pdf
        except Exception as e:
            if DEBUG:
                pretty_print(f"Error generating signed PDF: {str(e)}", "ERROR")
            return None

    def get_queryset(self):
        """Filter submissions based on user role"""
        user = self.request.user
        queryset = super().get_queryset()

        # Admins see all submissions
        if user.is_superuser:
            return queryset

        # Users see submissions they created
        if self.action == "list":
            return queryset.filter(submitter=user)

        # For approvers, include submissions they need to approve
        role_submissions = FormSubmission.objects.filter(
            status="pending",
            form_template__approval_workflows__approver_role=user.role,
            current_step=FormApprovalWorkflow.objects.filter(
                form_template=OuterRef("form_template"), approver_role=user.role
            ).values("order"),
        )

        return (queryset.filter(submitter=user) | role_submissions).distinct()

================
File: api/views/forms/form_template.py
================
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated, IsAdminUser
from ...models import FormTemplate
from ...serializers import FormTemplateSerializer

from utils import MethodNameMixin
from django.conf import settings

DEBUG = settings.DEBUG


class FormTemplateViewSet(viewsets.ModelViewSet, MethodNameMixin):
    """ViewSet for form templates"""

    serializer_class = FormTemplateSerializer
    queryset = FormTemplate.objects.all()
    permission_classes = [IsAuthenticated]

    # Admin-only access for create/update/delete operations
    def get_permissions(self):
        if self.action in ["create", "update", "partial_update", "destroy"]:
            self.permission_classes = [IsAdminUser]
        return super().get_permissions()

================
File: api/views/__init__.py
================
# Auth Related Views
from .authentication import (
    LoginView,
    RegisterView,
    AzureAuthViewSet,
)

# Admin dashboard viewsets
from .admin_dashboard import AdminDashboardViewSet

# User CRUD Operations
from .user_management import UserManagementViewSet

# Forms
from .forms import FormApprovalViewSet, FormTemplateViewSet, FormSubmissionViewSet

__all__ = [
    "LoginView",
    "RegisterView",
    "AzureAuthViewSet",
    "AdminDashboardViewSet",
    "UserManagementViewSet",
    "FormTemplateViewSet",
    "FormSubmissionViewSet",
    "FormApprovalViewSet",
]

================
File: api/views/admin_dashboard.py
================
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response

from ..serializers import AdminUserSerializer, UserSerializer
from .common import AdminRequiredMixin
from ..models import User
from utils import pretty_print, MethodNameMixin

from os import getenv

DEBUG = getenv("DEBUG")


class AdminDashboardViewSet(AdminRequiredMixin, viewsets.ModelViewSet, MethodNameMixin):
    """
    ViewSet for admin dashborad operations
    Includes user management and analytics
    """

    serializer_class = AdminUserSerializer
    queryset = User.objects.all()

    @action(detail=False, methods=["GET"])
    def users(self, request):
        """
        Pagination list of all users for admin
        EXAMPLE pagination:
            GET /api/admin/users/?page=1&page_size=5
        """
        page = int(request.query_params.get("page", 1))
        page_size = int(request.query_params.get("page_size", 10))
        offset = (page - 1) * page_size

        if DEBUG:
            pretty_print(
                f"Calculated (page,page_size,offset) for {self._get_method_name()}: {page, page_size, offset}",
                "DEBUG",
            )

        total_users = User.objects.count()
        users = User.objects.all().order_by("id")[offset : offset + page_size]

        return Response(
            {
                "total": total_users,
                "page": page,
                "page_size": page_size,
                "total_pages": (total_users + page_size - 1) // page_size,
                "results": UserSerializer(users, many=True).data,
            }
        )

    # TODO: implement chart view or stat view for frontend its going to utilize this
    @action(detail=False, methods=["get"])
    def user_stats(self, _):
        """Get user statistics for dashboard"""
        pretty_print(
            f"Getting user_stats for admin dashborad from {self._get_method_name()}",
            "INFO",
        )
        total_users = User.objects.count()
        active_users = User.objects.filter(is_active=True).count()
        return Response(
            {
                "total_users": total_users,
                "active_users": active_users,
                "inactive_users": total_users - active_users,
            }
        )

    def get_queryset(self):
        """Add custom filtering and ordering"""
        queryset = super().get_queryset()
        # add filters based on query params
        return queryset

    @action(detail=True, methods=["patch"])
    def toggle_status(self, request, pk=None):
        """Toggle user active status"""
        user = self.get_object()
        # Can not deactivate account for admin
        if user.is_superuser:
            return Response(
                {"error": "Cannot change status of superuser accounts"},
                status=status.HTTP_403_FORBIDDEN,
            )

        # prevent deactivating self
        # note that this case is covered by the one above since
        # an admin cant deactivate an admin but this is added as extra precautions
        if user.id == request.user.id:
            return Response(
                {"error": "Cannot change your own account status"},
                status=status.HTTP_403_FORBIDDEN,
            )

        if DEBUG:
            pretty_print(f"Toggling User Activity Status for {user.id}", "DEBUG")

        user.is_active = not user.is_active
        user.save()
        return Response(
            {"id": user.id, "email": user.email, "is_active": user.is_active}
        )

    @action(detail=True, methods=["patch"])
    def update_user(self, request, pk=None):
        """Update user information"""
        user = self.get_object()

        if DEBUG:
            pretty_print(
                f"Received Request inside {self._get_method_name()}: {request.data.items()}"
            )

        # Check if trying to update a superuser
        if user.is_superuser and not request.user.is_superuser:
            return Response(
                {"error": "Only superusers can modify other superuser accounts"},
                status=status.HTTP_403_FORBIDDEN,
            )

        # Check for unique constraint violations before applying changes
        email = request.data.get("email")
        username = request.data.get("username")
        role = request.data.get("role")

        errors = {}

        if user.role != role:
            pretty_print(
                f"Changing {user.username}'s role from {user.role} -> {role}", "DEBUG"
            )
            # if changing someone to an admin make sure they have this is_superuser set to True
            if role == "admin":
                user.is_superuser = True

            if role == "admin" or role == "staff":
                user.is_staff = True

            if user.role == "admin" and role != "admin":
                pretty_print(
                    "Cannot Change and admin's role to something with lower priveleges",
                    "WARNING",
                )
                errors["role"] = ["Cannot deprivilege an admin"]

        # Check email uniqueness
        if email and email != user.email and User.objects.filter(email=email).exists():
            errors["email"] = ["This email is already taken by another user."]

        # Check username uniqueness
        if (
            username
            and username != user.username
            and User.objects.filter(username=username).exists()
        ):
            errors["username"] = ["This username is already taken by another user."]

        # If found constraint violations, return early with error messages
        if errors:
            if DEBUG:
                pretty_print(f"Validation errors for user {user.id}: {errors}", "DEBUG")
            return Response(errors, status=status.HTTP_400_BAD_REQUEST)

        # No errors found continue
        serializer = self.get_serializer(user, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            if DEBUG:
                pretty_print(
                    f"Updated user {user.id} with data: {request.data}", "DEBUG"
                )
            return Response(serializer.data)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

================
File: api/views/authentication.py
================
from django.forms import ValidationError
from django.contrib.auth import authenticate, login
from django.contrib.auth.hashers import make_password

from rest_framework import viewsets, status, views
from rest_framework.decorators import action
from rest_framework.exceptions import (
    AuthenticationFailed,
    NotFound,
    PermissionDenied as DRFPermissionDenied,
)
from rest_framework.response import Response
from rest_framework.permissions import AllowAny

import jwt
import secrets

from utils import pretty_print, MethodNameMixin
from ..core import AccountInactiveError, InvalidCredentialsError
from ..serializers import LoginSerializer
from ..models import User
from django.conf import settings

DEBUG = settings.DEBUG


# TODO: expand to also interchangebly accept either username or email
class LoginView(views.APIView, MethodNameMixin):
    """Handle user login with username/password"""

    permission_classes = [AllowAny]

    def post(self, request):
        serializer = LoginSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)

        if DEBUG:
            pretty_print(
                f"Received Request from {self._get_method_name()}: {request}", "DEBUG"
            )

        username = request.data.get("username")
        password = request.data.get("password")

        if not username or not password:
            pretty_print(
                f"Error Encountered from {self._get_method_name()}: Please provide both username and password",
                "ERROR",
            )
            raise ValidationError("Please provide both username and password")

        user = authenticate(username=username, password=password)
        if not user:
            pretty_print(
                f"Error Encountered from {self._get_method_name()}: Invalid Credentials",
                "ERROR",
            )
            raise InvalidCredentialsError()

        # check if account is activated or not
        if not user.is_active:
            pretty_print(
                f"Error logging in user: {user.username} is not activated", "ERROR"
            )
            raise AccountInactiveError()

        # no errors log that user in
        login(request, user)

        # TODO: use this response in the frontend to fill up dashboard
        return Response(
            {
                "message": "Login successful",
                "user": {
                    "id": user.id,
                    "email": user.email,
                    "is_superuser": user.is_superuser,
                    "firstName": user.first_name,
                    "lastName": user.last_name,
                    "role": user.role,
                },
            }
        )


class RegisterView(views.APIView, MethodNameMixin):
    """Handle new user registration"""

    permission_classes = [AllowAny]

    def post(self, request):
        data = request.data

        if DEBUG:
            pretty_print(
                f"Received Request from {self._get_method_name()}: {data}", "DEBUG"
            )
        # Validate required fields
        required_fields = ["email", "username", "password", "firstName", "lastName"]
        for field in required_fields:
            if not data.get(field):
                pretty_print(
                    f"Encountered from {self._get_method_name()}: {field} is required",
                    "ERROR",
                )
                raise ValidationError(f"{field} is required")

        # Check if user already exists
        if User.objects.filter(email=data["email"]).exists():
            raise ValidationError("User with this email already exists")
            pretty_print(
                f"from {self._get_method_name()}: User with this email already exists",
                "ERROR",
            )
        if User.objects.filter(username=data["username"]).exists():
            pretty_print(
                f"from {self._get_method_name()}: User with this username already exists",
                "ERROR",
            )
            raise ValidationError("User with this username already exists")
        if (
            data.get("phone")
            and User.objects.filter(phone_number=data["phone"]).exists()
        ):
            pretty_print(
                f"from {self._get_method_name()}: User with this phone already exists",
                "ERROR",
            )

            raise ValidationError("User with this phone already exists")

        # Checks Passed Make User
        user = User.objects.create(
            username=data["username"],
            email=data["email"],
            password=make_password(data["password"]),
            first_name=data["firstName"],
            last_name=data["lastName"],
            phone_number=data.get("phone", ""),
            role="student",  # Enforce default role for registration
        )

        return Response(
            {
                "message": "User registered successfully",
                "user_id": user.id,
            },
            status=status.HTTP_201_CREATED,
        )


class AzureAuthViewSet(viewsets.ViewSet, MethodNameMixin):
    """Handle Microsoft Azure authentication"""

    permission_classes = [AllowAny]

    @action(detail=False, methods=["post"])
    def login(self, request):
        pretty_print("Starting Azure login process", "INFO")
        pretty_print(f"Received Request: {request}", "DEBUG")
        token = request.data.get("token")
        if not token:
            raise ValidationError("No Token Provided")

        payload = jwt.decode(
            token, options={"verify_signature": False}, algorithms=["RS256"]
        )

        if DEBUG:
            pretty_print(
                f"Token payload from {self._get_method_name()}: {payload}", "DEBUG"
            )

        if not payload["iss"].startswith("https://sts.windows.net"):
            raise AuthenticationFailed("Invalid token issuer")

        # extract login information
        email = (payload.get("upn") or payload.get("email") or "").lower()

        if not email:
            raise ValidationError("Email not found in token")

        user = User.objects.filter(email__iexact=email).first()
        if not user:
            raise NotFound("No account found with this email. Please register first.")

        # check if the user is deactivated or not
        if user.is_active:
            login(request, user, backend="django.contrib.auth.backends.ModelBackend")
            return Response(
                {
                    "message": "Login successful",
                    "user": {
                        "id": user.id,
                        "email": user.email,
                        "is_superuser": user.is_superuser,
                        "firstName": user.first_name,
                        "lastName": user.last_name,
                        "role": user.role,
                    },
                }
            )
        else:
            raise DRFPermissionDenied("User account is inactive")

    @action(detail=False, methods=["post"])
    def register(self, request):
        pretty_print("Starting Azure registration process", "INFO")
        token = request.data.get("token")
        if not token:
            raise ValidationError("No Token Provided")
        pretty_print(
            f"Received Token from {self._get_method_name()}: {token[:25]}...", "DEBUG"
        )

        # Decode Token without verification to extract claims
        payload = jwt.decode(
            token, options={"verify_signature": False}, algorithms=["RS256"]
        )
        if DEBUG:
            pretty_print(
                f"Token Decoded, issuer: {payload.get('iss', 'unknown')}", "DEBUG"
            )

        if not payload["iss"].startswith("https://sts.windows.net"):
            raise AuthenticationFailed("Invalid token Issuer")

        # extract  details from payload
        email = (payload.get("upn") or payload.get("email") or "").lower()
        first_name = payload.get("given_name", "")
        last_name = payload.get("family_name", "")

        if not email:
            raise ValidationError("Email not found in token")
        if User.objects.filter(email=email).exists():
            raise ValidationError("User with this email already exists")

        # new user start creating and account for them
        random_password = secrets.token_urlsafe(32)
        username = email.split("@")
        # username is taken rather than giving them an error hex it
        if User.objects.filter(username=username).exists():
            username = f"{username}_{secrets.token_hex(4)}"

        # all steps completed create user
        # TODO: we dont have roles defined anymore either remove role or add to schema
        user = User.objects.create_user(
            username=username,
            email=email,
            password=random_password,
            first_name=first_name,
            last_name=last_name,
            role="student",
        )
        pretty_print(f"Azure user created successfully, user_id: {user.id}", "INFO")

        return Response(
            {
                "message": "User Registered successfully!",
                "user": {
                    "id": user.id,
                    "email": user.email,
                    "firstName": user.first_name,
                    "lastName": user.last_name,
                    "role": user.role,
                },
            }
        )

================
File: api/views/common.py
================
from django.contrib.auth import PermissionDenied
from rest_framework import permissions


class AdminRequiredMixin:
    """
    Mixin to enforce admin-only access
    """

    permission_classes = [permissions.IsAdminUser]

    def check_admin(self, request):
        """Raise Error if a non admin is trying to access an admin only resource"""
        if not request.user.is_superuser:
            raise PermissionDenied("Only administrators can access this endpoint")

================
File: api/views/user_management.py
================
from rest_framework import viewsets
from rest_framework.permissions import IsAuthenticated, IsAdminUser, AllowAny
from rest_framework.decorators import action
from rest_framework.response import Response

from django.conf import settings

from utils import MethodNameMixin, pretty_print
from ..serializers import UserDetailSerializer, UserSerializer
from ..models import User
from ..core import IsAdminOrSelf, IsActiveUser

from typing import List


DEBUG = settings.DEBUG


class UserManagementViewSet(viewsets.ModelViewSet, MethodNameMixin):
    """
    ViewSet for basic user CRUD operations
    Some actions require admin privileges
    """

    serializer_class = UserSerializer
    queryset = User.objects.all()

    def get_serializer_class(self):
        if self.action == "retrieve":
            return UserDetailSerializer
        return UserSerializer

    @action(detail=False, methods=["GET"])
    def me(self, request):
        """Get current user's profile"""
        # NOTE: /users/me/ endpoint authentication middleware

        if DEBUG:
            pretty_print(
                f"Received Request from {self._get_method_name()}: {request}", "DEBUG"
            )

        serializer = UserDetailSerializer(request.user)
        return Response(serializer.data)

    def get_permissions(self) -> List:
        """
        Override to set custom permissions per action:

            - List/Retrieve: Authenticated users
            - Create: Anyone
            - Update/Delete: Admin only
        """
        if self.action in ["create"]:
            permission_classes = [AllowAny]
        elif self.action in ["update", "partial_update", "destroy"]:
            permission_classes = [IsAdminUser, IsAdminOrSelf]
        elif self.action == "me":
            permission_classes = [IsAuthenticated, IsActiveUser]
        else:
            permission_classes = [IsAuthenticated]
        return [permission() for permission in permission_classes]

================
File: api/__init__.py
================


================
File: api/admin.py
================
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import User

@admin.register(User)
class CustomUserAdmin(UserAdmin):
    list_display = ('username', 'email', 'is_superuser', 'created_at')
    list_filter = ('is_superuser', 'is_active', 'created_at')
    search_fields = ('username', 'email')
    ordering = ('-created_at',)
    
    # Fields to show in the edit form
    fieldsets = (
        (None, {'fields': ('username', 'email', 'password')}),
        ('Personal info', {'fields': ('phone_number', 'date_of_birth')}),
        ('Permissions', {'fields': ('is_active', 'is_superuser')}),
    )
    
    # Fields to show when creating a new user
    add_fieldsets = (
        (None, {
            'classes': ('wide',),
            'fields': ('username', 'email', 'password1', 'password2', 
                      'phone_number', 'date_of_birth', 'is_superuser'),
        }),
    )

================
File: api/apps.py
================
from django.apps import AppConfig
from django.urls import get_resolver, URLPattern, URLResolver
from utils import pretty_print


class ApiConfig(AppConfig):
    default_auto_field = "django.db.models.BigAutoField"
    name = "api"

    def ready(self):
        from django.conf import settings

        if settings.DEBUG:
            self.list_api_urls()

    def list_api_urls(self):
        resolver = get_resolver()

        def recursive_list(patterns, prefix=""):
            for pattern in patterns:
                if isinstance(pattern, URLPattern):
                    # Clean up URL pattern by removing regex and extra slashes

                    url = prefix + str(pattern.pattern)
                    clean_url = (
                        url.replace("^", "")
                        .replace("$", "")
                        .replace("//", "/")
                        .replace("(?P<format>[a-z0-9]+)/?", "")
                        .replace("(?P<pk>[/.]+)", ":id")
                        .strip("/")
                    )
                    # Only show if it's an API route or admin route
                    if clean_url.startswith(("api", "admin")):
                        pretty_print(clean_url, "INFO")
                elif isinstance(pattern, URLResolver):
                    new_prefix = (
                        f"{prefix}{pattern.pattern}/"
                        if prefix
                        else f"{pattern.pattern}/"
                    )
                    recursive_list(pattern.url_patterns, new_prefix)

        pretty_print(f"{'=' * 20} API Routes {'=' * 20}", "INFO")
        recursive_list(resolver.url_patterns)
        pretty_print("=" * 50, "INFO")

================
File: api/models.py
================
from django.db import models
from django.contrib.auth.models import (
    AbstractBaseUser,
    BaseUserManager,
    PermissionsMixin,
)

ROLE_CHOICES = (
    ("student", "Student"),
    ("admin", "Admin"),
    ("staff", "Staff"),
    # add additional roles as needed
)

FORM_STATUS_CHOICES = (
    ("draft", "Draft"),
    ("pending", "Pending Approval"),
    ("returned", "Returned for Changes"),
    ("approved", "Approved"),
    ("rejected", "Rejected"),
)


# IMPORTANT: override default django user table
class CustomUserManager(BaseUserManager):
    def create_user(self, username, email, password=None, **extra_fields):
        if not username:
            raise ValueError("Username is required")
        if not email:
            raise ValueError("Email is required")

        extra_fields.setdefault("role", "student")
        user = self.model(
            username=username, email=self.normalize_email(email), **extra_fields
        )
        user.set_password(password)
        user.save(using=self._db)
        return user

    def create_superuser(self, username, email, password=None, **extra_fields):
        extra_fields.setdefault(
            "role",
            "admin",
        )
        user = self.create_user(
            username=username, email=email, password=password, **extra_fields
        )
        user.is_superuser = True
        user.is_staff = True
        user.save(using=self._db)
        return user


class User(AbstractBaseUser, PermissionsMixin):
    # Required fields
    username = models.CharField(max_length=40, unique=True)
    email = models.EmailField(unique=True)
    password = models.CharField(max_length=128)  # Django handles this
    first_name = models.CharField(max_length=128, default="")
    last_name = models.CharField(max_length=128, default="")

    # Optional fields
    phone_number = models.CharField(max_length=15, blank=True)
    date_of_birth = models.DateField(null=True, blank=True)

    # User role
    # admin, staff, student
    role = models.CharField(max_length=30, choices=ROLE_CHOICES, default="student")

    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    # Status fields
    is_active = models.BooleanField(default=True)
    is_superuser = models.BooleanField(default=False)  # Replaces is_admin
    is_staff = models.BooleanField(default=False)  # needed for admin panel

    # signature to automatically sign forms
    signature = models.ImageField(upload_to="signatures/", null=True, blank=True)

    objects = CustomUserManager()

    # required fields for Django auth to work
    USERNAME_FIELD = "username"
    EMAIL_FIELD = "email"
    REQUIRED_FIELDS = ["email"]  # username is automatically required

    def __str__(self):
        return self.username


class FormTemplate(models.Model):
    """Stores template information for different form types"""

    name = models.CharField(max_length=100)

    description = models.TextField(blank=True)

    # store field schema as JSON
    field_schema = models.JSONField(help_text="JSON schema defining form fields")

    # number of approvals required
    required_approvals = models.PositiveIntegerField(default=1)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name


class FormApprovalWorkflow(models.Model):
    """Define who needs to approve which form template"""

    form_template = models.ForeignKey(
        FormTemplate, on_delete=models.CASCADE, related_name="approvals_workflows"
    )

    approver_role = models.CharField(max_length=30, choices=ROLE_CHOICES)

    order = models.PositiveIntegerField(help_text="Order in the approval sequence")

    class Meta:
        ordering = ["order"]
        unique_together = ["form_template", "order"]

    def __str__(self):
        return f"{self.form_template.name} - {self.approver_role} (Step {self.order})"


class FormSubmission(models.Model):
    """Stores submitted form data"""

    # Form Template Used specifically their id
    form_template = models.ForeignKey(
        FormTemplate, on_delete=models.CASCADE, related_name="submissions"
    )

    # Who submitted this form
    submitter = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="form_submissions"
    )

    form_data = models.JSONField(help_text="JSON data containing form field values")

    # The Updated PDF created from the users input
    current_pdf = models.FileField(upload_to="forms/form_pdfs/", null=True, blank=True)

    # To be able to retrieve back should be created from
    # form_pdfs/{user_id}_{form_template_name}_{form_submission_id}
    pdf_url = models.TextField(null=True)

    # pending | approved | rejected | ...
    status = models.CharField(
        max_length=20, choices=FORM_STATUS_CHOICES, default="draft"
    )

    current_step = models.PositiveIntegerField(default=0)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.form_template.name} - {self.submitter.username} ({self.status})"


class FormApproval(models.Model):
    """Individual approval records for form submissions"""

    form_submission = models.ForeignKey(
        FormSubmission, on_delete=models.CASCADE, related_name="approvals"
    )

    # Who approved the form should have a staff or admin role
    approver = models.ForeignKey(
        User, on_delete=models.CASCADE, related_name="form_approvals"
    )

    # Final Step Number
    step_number = models.PositiveIntegerField()

    decision = models.CharField(
        max_length=20,
        choices=(
            ("approved", "Approved"),
            ("returned", "Returned for Changes"),
            ("rejected", "Rejected"),
        ),
    )
    # In case it was Rejected
    comments = models.TextField(blank=True)

    # Should have staff signature
    signed_pdf = models.FileField(upload_to="forms/signed_pdfs/", null=True, blank=True)

    # to quickly locate should be similiar to
    # {approver_id}_{form_type}_{approval_id}
    signed_pdf_url = models.TextField(null=True)

    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ["form_submission", "approver", "step_number"]

    def __str__(self):
        return f"{self.form_submission} - {self.approver.username} ({self.decision})"

================
File: api/urls.py
================
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import (
    LoginView,
    RegisterView,
    AzureAuthViewSet,
    AdminDashboardViewSet,
    UserManagementViewSet,
    FormApprovalViewSet,
    FormSubmissionViewSet,
    FormTemplateViewSet,
)


router = DefaultRouter()
router.register(r"azure", AzureAuthViewSet, basename="azure")
# makes new url admin
router.register(r"admin", AdminDashboardViewSet, basename="admin")
router.register(r"users", UserManagementViewSet, basename="users")
router.register(r"forms/templates", FormTemplateViewSet, basename="form-templates")
router.register(r"forms/submission", FormSubmissionViewSet, basename="form-submissions")
router.register(r"forms/approvals", FormApprovalViewSet, basename="form-approvals")


urlpatterns = [
    path("login/", LoginView.as_view(), name="login"),
    path("register/", RegisterView.as_view(), name="register"),
    # includes above router.register
    path("", include(router.urls)),
]

================
File: config/asgi.py
================
"""
ASGI config for config project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_asgi_application()

================
File: config/settings.py
================
import os
from pathlib import Path
from dotenv import load_dotenv
from utils import pretty_print
import sys

# Load dotenv variables
load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = os.getenv("SECRET_KEY")

AUTH_USER_MODEL = "api.User"

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = os.getenv("DEBUG", "False") == "True"


# WARNING: change in production
ALLOWED_HOSTS = [
    os.getenv("WEBSITE_HOSTNAME", "localhost"),
    ".azurewebsites.net",
    "127.0.0.1",
]


# Application definition

INSTALLED_APPS = [
    "api",
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "rest_framework",
    "drf_spectacular",
    "corsheaders",
    "django_auth_adfs",
]

MIDDLEWARE = [
    "django.middleware.security.SecurityMiddleware",
    "django.contrib.sessions.middleware.SessionMiddleware",
    "corsheaders.middleware.CorsMiddleware",
    "django.middleware.common.CommonMiddleware",
    "django.middleware.csrf.CsrfViewMiddleware",
    "django.contrib.auth.middleware.AuthenticationMiddleware",
    "django.contrib.messages.middleware.MessageMiddleware",
    "django.middleware.clickjacking.XFrameOptionsMiddleware",
    "whitenoise.middleware.WhiteNoiseMiddleware",
]


# Azure Entra ID
AUTH_ADFS = {
    "AUDIENCE": os.getenv("MICROSOFT_GRAPH_KEY"),
    "CLIENT_ID": os.getenv("MICROSOFT_GRAPH_KEY"),
    "CLIENT_SECRET": os.getenv("MICROSOFT_GRAPH_SECRET"),
    "TENANT_ID": os.getenv("MICROSOFT_TENANT_ID"),
    "RELYING_PARTY_ID": os.getenv("MICROSOFT_GRAPH_KEY"),
    "USERNAME_CLAIM": "upn",
    "CLAIM_MAPPING": {
        "first_name": "given_name",
        "last_name": "family_name",
        "email": "upn",
    },
    "RETRIES": 3,  # Number of retries for retrieving certificates
}


AUTHENTICATION_BACKENDS = (
    "django_auth_adfs.backend.AdfsAuthCodeBackend",
    "django.contrib.auth.backends.ModelBackend",
)


STATICFILES_STORAGE = "whitenoise.storage.CompressedManifestStaticFilesStorage"

ROOT_URLCONF = "config.urls"

TEMPLATES = [
    {
        "BACKEND": "django.template.backends.django.DjangoTemplates",
        "DIRS": [],
        "APP_DIRS": True,
        "OPTIONS": {
            "context_processors": [
                "django.template.context_processors.debug",
                "django.template.context_processors.request",
                "django.contrib.auth.context_processors.auth",
                "django.contrib.messages.context_processors.messages",
            ],
        },
    },
]

WSGI_APPLICATION = "config.wsgi.application"


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases
if DEBUG:
    pretty_print("Got .env THIS FILE SHOULD NOT BE EMPTY", "WARNING")
    pretty_print(f"DB_NAME: {os.getenv('DB_NAME')}", "WARNING")
    pretty_print(f"DB_USER: {os.getenv('DB_USER')}", "WARNING")
    pretty_print(f"DB_PASSWORD: {os.getenv('DB_PASSWORD')}", "WARNING")
    pretty_print(f"DB_HOST: {os.getenv('DB_HOST')}", "WARNING")
    pretty_print(f"DB_PORT: {os.getenv('DB_PORT')}", "WARNING")
    pretty_print(f"MICROSOFT_GRAPH_KEY: {os.getenv('MICROSOFT_GRAPH_KEY')}", "WARNING")
    pretty_print(
        f"MICROSOFT_GRAPH_SECRET: {os.getenv('MICROSOFT_GRAPH_SECRET')}", "WARNING"
    )
    pretty_print(
        f"MICROSOFT_BACKEND_REDIRECT_URL: {os.getenv('MICROSOFT_BACKEND_REDIRECT_URL')}",
        "WARNING",
    )
    pretty_print(
        f"MICROSOFT_FRONTEND_REDIRECT_URL: {os.getenv('MICROSOFT_FRONTEND_REDIRECT_URL')}",
        "WARNING",
    )


DATABASES = {
    "default": {
        "ENGINE": "django.db.backends.postgresql",
        "NAME": os.getenv("DB_NAME"),
        "USER": os.getenv("DB_USER"),
        "PASSWORD": os.getenv("DB_PASSWORD"),
        "HOST": os.getenv("DB_HOST"),
        "PORT": os.getenv("DB_PORT"),
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators
AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/
LANGUAGE_CODE = "en-us"
TIME_ZONE = "UTC"
USE_I18N = True
USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/
STATIC_URL = "static/"
STATIC_ROOT = BASE_DIR / "static"
MEDIA_URL = "media/"
MEDIA_ROOT = BASE_DIR / "media"

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field
DEFAULT_AUTO_FIELD = "django.db.models.BigAutoField"

# CORS settings
CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
]

CORS_ALLOW_HEADERS = [
    "accept",
    "authorization",
    "content-type",
    "user-agent",
    "x-csrftoken",
    "x-request-with",
]

CORS_ALLOW_CREDENTIALS = True


# REST Framework settings
REST_FRAMEWORK = {
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.SessionAuthentication",
        "rest_framework.authentication.BasicAuthentication",
    ],
    "DEFAULT_PERMISSION_CLASSES": [
        "rest_framework.permissions.IsAuthenticated",
    ],
    "DEFAULT_SCHEMA_CLASS": "rest_framework.schemas.openapi.AutoSchema",
}


CSRF_TRUSTED_ORIGINS = [
    "http://localhost:3000",
]

================
File: config/urls.py
================
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path("api/", include("api.urls")),
    path('admin/', admin.site.urls)

]

================
File: config/wsgi.py
================
"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()

================
File: templates/forms/term_withdrawal.tex
================
\documentclass[11pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{tgschola}
\usepackage{multirow}
\usepackage{array}
\usepackage{xcolor}
\usepackage{hyperref}

% Define placeholder variables that will be replaced by Python
\newcommand{\studentName}{$STUDENT_NAME$}
\newcommand{\studentID}{$STUDENT_ID$}
\newcommand{\phoneNumber}{$PHONE_NUMBER$}
\newcommand{\emailAddress}{$EMAIL_ADDRESS$}
\newcommand{\programPlan}{$PROGRAM_PLAN$}
\newcommand{\academicCareer}{$ACADEMIC_CAREER$}
\newcommand{\withdrawalYear}{$WITHDRAWAL_YEAR$}
\newcommand{\seasonFall}{$FALL_SELECTED$}
\newcommand{\seasonSpring}{$SPRING_SELECTED$}
\newcommand{\seasonSummer}{$SUMMER_SELECTED$}
\newcommand{\studentSignature}{$STUDENT_SIGNATURE$}
\newcommand{\currentDate}{$CURRENT_DATE$}

% NOTE: For checkboxes in the form
\newcommand{\checkbox}[1]{$#1$}

\begin{document}
\thispagestyle{empty}

% NOTE: University header
% \begin{minipage}{0.5\textwidth}
%   \includegraphics[width=3in]{$UNIVERSITY_LOGO$}
% \end{minipage}
\begin{minipage}{0.5\textwidth}
  \raggedleft
  Submit in person to:\\
  Office of the University Registrar at\\
  the Welcome Center\\
  or\\
  Fax to: 713-743-8342
\end{minipage}

\begin{center}
  \textbf{\Large Student Request for Official Term Withdrawal}
\end{center}

\noindent\begin{tabular}{@{}p{1.8in}p{4.5in}@{}}
Student Name: & \underline{\studentName} \\
 & \scriptsize{Last \hspace{1.5in} First \hspace{1.5in} Middle} \\
\end{tabular}
\hfill myUH ID: \underline{\studentID}

\noindent\begin{tabular}{@{}p{1.8in}p{4.5in}@{}}
Phone \#: & \underline{\phoneNumber} \\
\end{tabular}
\noindent\begin{tabular}{@{}p{1.8in}p{4.5in}@{}}
Email: & \underline{\emailAddress} \\
\end{tabular}

\noindent\begin{tabular}{@{}p{1.8in}p{4.5in}@{}}
Program/Plan: & \underline{\programPlan} \\
\end{tabular}
\hfill Academic Career: \underline{\academicCareer}

\noindent\begin{tabular}{@{}p{1.8in}@{}}
Withdrawal Term: \\
\end{tabular}
\underline{\withdrawalYear} \hspace{0.2in} Fall \seasonFall \hspace{0.2in} Spring \seasonSpring \hspace{0.2in} Summer \seasonSummer
\begin{flushright}
\scriptsize{Year}
\end{flushright}

\vspace{0.2cm}
\textbf{Initial all that apply:}

\begin{itemize}
\setlength\itemsep{0.5em}
\item[] \textbf{STUDENTS RECEIVING FINANCIAL AID} — I understand that if I withdrawal from \textbf{ALL} classes I may owe financial aid back to the university based on federal regulations that require a refund calculation to determine the Federal Title IV Funds I earned. I understand that any future financial aid will be canceled. I understand that if I withdrawal prior to the Official Reporting Day of a term, all state and institutional aid will be canceled and I will owe this to the university. I understand that withdrawing from classes will impact my Satisfactory Academic Progress standing and may cause me to lose my future financial aid eligibility. I understand that if I am receiving a university scholarship I may lose scholarship eligibility.

\item[] \textbf{INTERNATIONAL STUDENTS HOLDING F-1 OR J-1 STUDENT VISAS} — I understand that federal regulations require me to obtain authorization for a reduced course load from the International Student and Scholar Services Office (ISSSO) prior to withdrawing from the university and that I have obtained such authorization.

\item[] \textbf{STUDENT-ATHLETES} — I understand that I must clear any financial holds related to student-athlete services and return all textbooks, uniforms, and equipment to avoid being charged for those items. I must also meet with Student-Athlete Development and the Office of Athletics' Compliance for information about current and future academic eligibility status and cancellation of remaining aid.

\item[] \textbf{VETERANS} — I understand that an official term withdrawal from the university will automatically initiate a recalculation of tuition, fees and the rate of pursuit (enrollment status) reported to the VA. I Understand that withdrawing from the university may impact my GI Bill benefits, holding me responsible for the repayment of a portion of my tuition, fees and housing as determined by the VA. For more information, I will consult with a Certifying Official for Veteran Educational Benefits at the Office of the University Registrar counter in the Welcome Center.

\item[] \textbf{GRADUATE/PROFESSIONAL STUDENTS} — I understand that any university support (i.e. graduate assignment, DSTF) will be cancelled. Withdrawals after the official reporting day require that I meet with my Academic Advisor and provide instructor-approved drop forms for each class (attached).

\item[] \textbf{DOCTORAL STUDENTS} — I understand that I must file a leave of absence with the Office of Graduate and Professional Studies.

\item[] \textbf{STUDENT HOUSING} — I understand that my housing agreement outlines important information regarding housing cancelation and refunds. I understand that I need to check out of my room, complete all check out processes, and return my keys to avoid additional fees.

\item[] \textbf{DINING SERVICES} — I understand that withdrawing from the university does not automatically relieve me of my obligation to pay outstanding charges stemming from my purchase of a UH Dining Services meal plan. To receive any available credit for the unused portion of my meal plan I must submit a meal plan petition requesting approval for cancellation. Visit \url{http://www.uh.edu/auxiliaryservices/dining/mealpetition.htm} for instructions on filing meal plan petitions.

\item[] \textbf{PARKING AND TRANSPORTATION} — I understand that withdrawing from the university does not relieve me of my obligation to pay outstanding charges stemming from my purchase of a UH parking permit or parking citations received. To receive any available credit for my unused parking permit I understand that I must return the permit to Parking and Transportation Services.
\end{itemize}

\begin{center}
\small\textbf{THE UNIVERSITY DOES NOT ASSUME RESPONSIBILITY FOR LOST OR REDUCED REFUNDS, LOSS OF FINANCIAL AID OR OTHER ENTITLEMENTS IF YOU FAIL TO SEEK ADVISMENT FROM THE APPROPRIATE OFFICES.}
\end{center}

I understand that a withdrawal from \textbf{ALL} classes may have various academic implications including my degree plan, course requirements, prerequisites and other college policies. For more information, I will consult with my academic advisor directly.

I understand that I may have an outstanding balance which, if unpaid will prevent me from future enrollment, ordering transcripts or utilizing other university services until paid in full. I understand that additional fees may be applied to any unpaid balance.

I further understand that my withdrawal from \textbf{ALL} classes is effective the date this form is processed and my partial refund, if any, will be calculated based on that effective date and in accordance with the published refund schedule. Any forms faxed outside business hours, during weekends or holidays will be processed and effective the next business day.

I further understand that I am dropping \textbf{ALL} classes and withdrawing from the university.

\vspace{0.5cm}
\begin{tabular}{@{}p{2.5in}@{\hspace{1in}}p{2.5in}@{}}
\studentSignature & \currentDate \\
\cline{1-1}\cline{2-2}
Student's Signature & Date\\
\end{tabular}

\end{document}

================
File: utils/__init__.py
================
from .prettyPrint import pretty_print
from .MethodNameMixin import MethodNameMixin
from .formgenerator import FormPDFGenerator

================
File: utils/formgenerator.py
================
import os
import tempfile
from datetime import datetime
from django.conf import settings
from django.core.files.base import ContentFile
import subprocess

from utils import pretty_print


class FormPDFGenerator:
    """
    Utility class to generate PDFs from LaTeX templates
    for the form approval system
    """

    def __init__(self):
        # Base directory for templates
        self.template_dir = os.path.join(settings.BASE_DIR, "templates", "forms")

        # Create the directory if it doesn't exist
        os.makedirs(self.template_dir, exist_ok=True)

        # Path to the university logo
        self.logo_path = os.path.join(
            settings.STATIC_ROOT, "img", "university_logo.png"
        )

    def generate_template_form(self, template_name: str, user, form_data):
        """
        Route to the appropriate template generation function based on template name

        Args:
            template_name: String identifier for the form template
            user: The User model instance
            form_data: Dictionary containing form field values

        Returns:
            The generated PDF from the appropriate template
        """

        pretty_print(
            f"received params in generate_template_form {template_name}, {user}, {list(form_data)}",
            "DEBUG",
        )
        if template_name == "withdrawal":
            return self.generate_withdrawal_form
        elif template_name == "graduate":
            pretty_print("GRADUATE TEMPLATE NOT YET IMPLEMENTED", "WARNING")
            return None
        else:
            pretty_print(f"NOT A VALID TEMPLATE_NAME: {template_name}", "ERROR")
            raise ValueError(f"Invalid Template Name: {template_name}")

    def generate_withdrawal_form(self, user, form_data):
        """
        Generate a term withdrawal form PDF for the given user and form data

        Args:
            user: The User model instance
            form_data: Dictionary containing form field values

        Returns:
            BytesIO object containing the generated PDF
        """
        # Get template content
        template_path = os.path.join(self.template_dir, "term_withdrawal.tex")
        with open(template_path, "r") as file:
            template_content = file.read()

        # NOTE: Format student name
        student_name = f"{user.last_name}, {user.first_name} {user.middle_name if hasattr(user, 'middle_name') else ''}"

        # NOTE: Format checkboxes for semester selection
        fall_selected = "\\square" if form_data.get("season") == "Fall" else "\\square"
        spring_selected = (
            "\\square" if form_data.get("season") == "Spring" else "\\square"
        )
        summer_selected = (
            "\\square" if form_data.get("season") == "Summer" else "\\square"
        )

        # NOTE: Check which one is selected and mark it with ✓
        if form_data.get("season") == "Fall":
            fall_selected = "\\checked"
        elif form_data.get("season") == "Spring":
            spring_selected = "\\checked"
        elif form_data.get("season") == "Summer":
            summer_selected = "\\checked"

        # NOTE: Current date in MM/DD/YYYY format
        current_date = datetime.now().strftime("%m/%d/%Y")

        # IMPORTANT: Replace placeholders with actual values
        replacements = {
            "$STUDENT_NAME$": student_name,
            "$STUDENT_ID$": str(form_data.get("student_id", "")) or "",
            "$PHONE_NUMBER$": str(form_data.get("phone_number", user.phone_number))
            or "",
            "$EMAIL_ADDRESS$": form_data.get("email", user.email),
            "$PROGRAM_PLAN$": form_data.get("program_plan", ""),
            "$ACADEMIC_CAREER$": form_data.get("academic_career", ""),
            "$WITHDRAWAL_YEAR$": str(form_data.get("year", datetime.now().year)),
            "$FALL_SELECTED$": fall_selected,
            "$SPRING_SELECTED$": spring_selected,
            "$SUMMER_SELECTED$": summer_selected,
            "$CURRENT_DATE$": current_date,
            "$UNIVERSITY_LOGO$": self.logo_path,
        }

        # TODO: make signatures a required field before users are able to access form requests
        # IMPORTANT: Handle signature - if user has a signature in their profile, use it
        # Otherwise leave it blank
        if user.signature:
            # Create a temporary signature file from the signature in the user model
            signature_content = self._process_signature(user)
            replacements["$STUDENT_SIGNATURE$"] = signature_content
        else:
            replacements["$STUDENT_SIGNATURE$"] = ""

        # Replace all placeholders
        for placeholder, value in replacements.items():
            template_content = template_content.replace(placeholder, str(value))

        # Create PDF using pdflatex in a temporary directory
        return self._compile_latex(template_content)

    def _process_signature(self, user):
        """Process user signature for inclusion in the PDF"""
        # This assumes the signature is stored as an ImageField in the User model
        if not user.signature:
            pretty_print(f"User {user} does not have a signature on file", "WARNING")
            return ""

        # Return the path to the signature file
        # WARNING:
        # TODO: store user signatures as img byte code
        try:
            sig_path = user.signature.path  # For local file storage
            return sig_path
        except ValueError:
            content = user.signature.read()
            with tempfile.NamedTemporaryFile(delete=False, suffix=".png") as tmp:
                tmp.write(content)
                return tmp.name

    # TODO: only handles withdrawal form for right now make it so that it switches file path name with form type
    def _compile_latex(self, latex_content):
        """
        Compile LaTeX content to PDF

        Args:
            latex_content: String containing the LaTeX document

        Returns:
            Path to the generated PDF file
        """
        # Create a temporary directory for compilation
        with tempfile.TemporaryDirectory() as temp_dir:
            # Create temporary LaTeX file
            tex_file = os.path.join(temp_dir, "document.tex")
            with open(tex_file, "w") as file:
                file.write(latex_content)

            # Compile LaTeX to PDF
            subprocess.run(
                ["pdflatex", "-interaction=nonstopmode", tex_file],
                cwd=temp_dir,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
            )

            # Check if PDF was created
            pdf_file = os.path.join(temp_dir, "document.pdf")
            if not os.path.exists(pdf_file):
                raise Exception("Failed to generate PDF")

            # Read the PDF file
            with open(pdf_file, "rb") as file:
                pdf_content = file.read()

            # Return the PDF content as a ContentFile
            return ContentFile(pdf_content, name="term_withdrawal.pdf")

================
File: utils/MethodNameMixin.py
================
import inspect


class MethodNameMixin:
    def _get_method_name(self) -> str | None:
        """Returns name of th calling method and its class."""
        return (
            f"{self.__class__.__name__}.{inspect.currentframe().f_back.f_code.co_name}"
        )

================
File: utils/prettyPrint.py
================
from colorama import Fore, Back, Style, init  # pretty print colors


# For Windows
init(autoreset=True)


def pretty_print(console_text: str, text_type: str = "DEBUG") -> None:
    """
    Pretty prints colors to the terminal to add more indication of what type of message is being printed

    Args:
        console_text (str): text to be outputted to the console
        text_type (str): type of text thats being outputted types are DEBUG | ERROR | INFO | WARNING

    Example:
        >>> pretty_print('this is an info message', 'INFO')
    """
    fg, bg, style = (None, None, None)

    # choosing appropriate colors
    if text_type.upper() == "DEBUG":
        fg, bg, style = Fore.CYAN, None, Style.DIM
    elif text_type.upper() == "INFO":
        fg, bg, style = Fore.GREEN, None, Style.NORMAL
    elif text_type.upper() == "ERROR":
        fg, bg, style = Fore.RED, Back.BLACK, Style.BRIGHT
    elif text_type.upper() == "WARNING":
        fg, bg, style = Fore.YELLOW, None, Style.BRIGHT
    else:
        fg, bg, style = Fore.GREEN, None, Style.NORMAL
        print(
            f"{fg}[INFO]: passed param text_type: {text_type} is not a valid text type using default text_type: INFO{Style.RESET_ALL}"
        )

    # printing actual message
    # Style.RESET_ALL is used to revert pack to default terminal fg,bg,style
    print(
        f"{fg}{bg if bg is not None else ''}{style}[{text_type}] {console_text}{Style.RESET_ALL}"
    )

================
File: Dockerfile
================
FROM python:3.11-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy project files
COPY . .

# Copy .env file
COPY .env .

# Expose port
EXPOSE 8000

# Run the application
CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]

================
File: environment.yml
================
name: backend
channels:
  - conda-forge
  - defaults
dependencies:
  - python
  - django
  - psycopg2
  - python-dotenv
  - djangorestframework
  - django-cors-headers
  - pip
  - whitenoise=6.4.0
  - python-dotenv
  - wfastcgi=3.0.0
  - social-auth-app-django=5.4.3
  - django-auth-adfs
  - colorama=0.4.6
  - drf-spectacular
  - pillow

================
File: manage.py
================
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""

import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "config.settings")
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == "__main__":
    main()

================
File: requirements.txt
================
Django==5.0.1
whitenoise==6.4.0
wfastcgi==3.0.0
psycopg2-binary==2.9.9
python-dotenv==1.0.0
djangorestframework==3.14.0
django-cors-headers==4.3.1
social-auth-app-django==5.4.3
django-auth-adfs==1.15.0
colorama==0.4.6
drf_spectacular
pillow
PyLaTex==1.4.1
python-magic==0.4.27

================
File: startup.sh
================
#!/bin/bash

python manage.py collectstatic --noinput
python manage.py migrate
gunicorn your_project.wsgi:application --bind=0.0.0.0:8000

================
File: startupLinux.sh
================
#!/bin/bash

echo "=========================================="
echo "  Django Project Management Script"
echo "=========================================="
echo "Select an option:"
echo "1) Create and apply migrations"
echo "2) Create a superuser"
echo "3) Start the Django development server"
echo "4) Open the database shell"
echo "5) Run Django shell"
echo "6) Collect static files"
echo "7) Check for system checks"
echo "8) Exit"
echo "=========================================="
read -p "Enter your choice: " choice

case $choice in
    1)
        echo "Creating and applying migrations..."
        python manage.py makemigrations
        python manage.py migrate
        ;;
    2)
        echo "Creating a superuser..."
        python manage.py createsuperuser
        ;;
    3)
        echo "Starting the Django development server on port 8000..."
        python manage.py runserver 8000
        ;;
    4)
        echo "Opening the database shell..."
        python manage.py dbshell
        ;;
    5)
        echo "Opening the Django shell..."
        python manage.py shell
        ;;
    6)
        echo "Collecting static files..."
        python manage.py collectstatic --noinput
        ;;
    7)
        echo "Running Django system checks..."
        python manage.py check
        ;;
    8)
        echo "Exiting..."
        exit 0
        ;;
    *)
        echo "Invalid option, please select a valid number."
        ;;
esac
